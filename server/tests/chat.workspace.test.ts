/**
 * Chat Workspace Resolution Tests
 * 
 * Tests workspace resolution logic in /chat and /chat/openai endpoints
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach } from '@jest/globals';
import { PrismaClient } from '@prisma/client';
import request from 'supertest';
import express from 'express';
import { app } from '../src/index';

const prisma = new PrismaClient();

// Mock OpenAI client to avoid actual API calls
jest.mock('../src/services/openaiClient', () => ({
  isOpenAIConfigured: () => true,
  default: {
    chat: {
      completions: {
        create: jest.fn().mockResolvedValue({
          choices: [{ message: { content: 'Test response' } }],
          usage: { prompt_tokens: 10, completion_tokens: 20, total_tokens: 30 },
        }),
      },
    },
  },
}));

describe('Chat Workspace Resolution', () => {
  let testUserId: string;
  let testWorkspaceId: string;
  let authToken: string;

  beforeAll(async () => {
    // Create test user
    const testUser = await prisma.user.create({
      data: {
        email: 'test-workspace@example.com',
        provider: 'local',
        name: 'Test User',
        credits: 1000,
      },
    });
    testUserId = testUser.id;

    // Create auth token (simplified - in real app use proper auth)
    authToken = 'test-token'; // This would be generated by auth service
  });

  afterAll(async () => {
    // Cleanup
    await prisma.workspace.deleteMany({ where: { userId: testUserId } });
    await prisma.user.delete({ where: { id: testUserId } });
    await prisma.$disconnect();
  });

  beforeEach(async () => {
    // Clean workspaces before each test
    await prisma.workspace.deleteMany({ where: { userId: testUserId } });
  });

  describe('Case A: Correct workspaceId provided', () => {
    it('should use the provided workspaceId when it exists', async () => {
      // Create workspace
      const workspace = await prisma.workspace.create({
        data: {
          userId: testUserId,
          name: 'Test Workspace',
          icon: '✨',
        },
      });
      testWorkspaceId = workspace.id;

      // Make chat request with correct workspaceId
      const response = await request(app)
        .post('/chat/openai')
        .set('Authorization', `Bearer ${authToken}`)
        .set('x-workspace-id', testWorkspaceId)
        .send({
          messages: [{ role: 'user', content: 'Hello' }],
          modelId: 'synexa-gpt-5.1',
        });

      // Should not return 404
      expect(response.status).not.toBe(404);
      expect(response.body.errorCode).not.toBe('workspace_not_found');
      
      // Should return successful response
      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('reply');
    });

    it('should use workspaceId from body when provided', async () => {
      // Create workspace
      const workspace = await prisma.workspace.create({
        data: {
          userId: testUserId,
          name: 'Test Workspace',
          icon: '✨',
        },
      });
      testWorkspaceId = workspace.id;

      // Make chat request with workspaceId in body
      const response = await request(app)
        .post('/chat/openai')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          messages: [{ role: 'user', content: 'Hello' }],
          modelId: 'synexa-gpt-5.1',
          workspaceId: testWorkspaceId,
        });

      // Should not return 404
      expect(response.status).not.toBe(404);
      expect(response.body.errorCode).not.toBe('workspace_not_found');
      
      // Should return successful response
      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('reply');
    });
  });

  describe('Case B: Incorrect workspaceId provided', () => {
    it('should fallback to first workspace when incorrect workspaceId provided', async () => {
      // Create workspace
      const workspace = await prisma.workspace.create({
        data: {
          userId: testUserId,
          name: 'Test Workspace',
          icon: '✨',
        },
      });
      testWorkspaceId = workspace.id;

      // Make chat request with incorrect workspaceId
      const response = await request(app)
        .post('/chat/openai')
        .set('Authorization', `Bearer ${authToken}`)
        .set('x-workspace-id', 'incorrect-workspace-id')
        .send({
          messages: [{ role: 'user', content: 'Hello' }],
          modelId: 'synexa-gpt-5.1',
        });

      // Should not return 404 workspace_not_found
      expect(response.status).not.toBe(404);
      expect(response.body.errorCode).not.toBe('workspace_not_found');
      
      // Should return successful response (fallback workspace used)
      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('reply');
      
      // Should indicate fallback was used
      expect(response.body.workspaceFallbackUsed).toBe(true);
      expect(response.body.resolvedWorkspaceId).toBe(testWorkspaceId);
    });

    it('should use first workspace when workspaceId not provided', async () => {
      // Create workspace
      const workspace = await prisma.workspace.create({
        data: {
          userId: testUserId,
          name: 'Test Workspace',
          icon: '✨',
        },
      });
      testWorkspaceId = workspace.id;

      // Make chat request without workspaceId
      const response = await request(app)
        .post('/chat/openai')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          messages: [{ role: 'user', content: 'Hello' }],
          modelId: 'synexa-gpt-5.1',
        });

      // Should return successful response
      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('reply');
      expect(response.body.resolvedWorkspaceId).toBe(testWorkspaceId);
    });
  });

  describe('Case C: No workspaces', () => {
    it('should return no_workspace error when user has no workspaces', async () => {
      // Don't create any workspace

      // Make chat request
      const response = await request(app)
        .post('/chat/openai')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          messages: [{ role: 'user', content: 'Hello' }],
          modelId: 'synexa-gpt-5.1',
        });

      // Should return 404 with no_workspace error
      expect(response.status).toBe(404);
      expect(response.body.errorCode).toBe('no_workspace');
      expect(response.body.errorType).toBe('not_found');
      expect(response.body.message).toBe('No workspace found for this account');
      
      // Should not have plain "error" field
      expect(response.body.error).toBeUndefined();
    });
  });
});








